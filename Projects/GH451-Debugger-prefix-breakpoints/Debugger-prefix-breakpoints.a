;ACME 0.96.4

!cpu 6502	; Compatible with all Apple2's
!to "Debugger-prefix-breakpoints", plain
!sl "Debugger-prefix-breakpoints.labels"
*=$6000

;------------------------------------------------------------------------------

!source "AppleDefs.a"
!source "HardDiskDefs.a"

;------------------------------------------------------------------------------

; Debugger breakpoint tests to check the address prefixes
;
; Enhanced //e, -aux rw3 (1MiB = 16x 64KiB), -s3 saturn (128KiB = 8x 16KiB)
;
; *** DMA tests ***
;
; Tests: (DMA write / HDD read), LC is r/w & 4K-bank 2
; . bpmw d000			: read block #1 to d000-d1ff [hit]
; . bpmw 0/d200			: read block #1 to d200-d3ff [hit]
; . bpmw 0/l1/d400		: read block #1 to d400-d5ff
; . bpmw 0/l2/d600		: read block #1 to d600-d7ff [hit]
; . bpmw 0/l1/d680,100	: read block #1 to d700-d900, BP range overlapping before d700, hit at d700
; . bpmw 0/l1/d880,100	: read block #1 to d700-d900, BP range overlapping after  d700, hit at d880
;
; Tests: (DMA write / HDD read), LC is r/w & 4K-bank*1*
; NB. same BPs as 4K-bank 2 above
; . bpmw d000			: read block #1 to d000-d1ff [hit]
; . bpmw 0/d200			: read block #1 to d200-d3ff [hit]
; . bpmw 0/l1/d400		: read block #1 to d400-d5ff [hit]
; . bpmw 0/l2/d600		: read block #1 to d600-d7ff
; . bpmw 0/l1/d680,100	: read block #1 to d700-d900, BP range overlapping before d700, hit at d700 [hit]
; . bpmw 0/l1/d880,100	: read block #1 to d700-d900, BP range overlapping after  d700, hit at d880 [hit]
;
; Tests: (DMA read  / HDD write), LC is r/w & 4K-bank 2
; . bpmr d800			: write block #1 to d800-d9ff [hit]
; . bpmr 0/da00			: write block #1 to da00-dbff [hit]
; . bpmr 0/l1/dc00		: write block #1 to dc00-ddff
; . bpmr 0/l2/de00		: write block #1 to de00-dfff [hit]
; . bpmr 0/l1/de80,100	: write block #1 to df00-e100, BP range overlapping before df00, hit at df00
; . bpmr 0/l1/e080,100	: write block #1 to df00-e100, BP range overlapping after  df00, hit at e080 [hit]
;
; Tests: (DMA read  / HDD write), LC is r/w & 4K-bank*1*
; NB. same BPs as 4K-bank 2 above
; . bpmr d800			: write block #1 to d800-d9ff [hit]
; . bpmr 0/da00			: write block #1 to da00-dbff [hit]
; . bpmr 0/l1/dc00		: write block #1 to dc00-ddff [hit]
; . bpmr 0/l2/de00		: write block #1 to de00-dfff
; . bpmr 0/l1/de80,100	: write block #1 to df00-e100, BP range overlapping before df00, hit at df00 [hit]
; . bpmr 0/l1/e080,100	: write block #1 to df00-e100, BP range overlapping after  df00, hit at e080 [hit]
;
; *** CPU tests ***
;
; Test: (CPU PC): using ALTZP, RAMRD & 80STORE/PAGE2 soft-switches
; . bp 0/l2/d000		; [hit]
; . bp 0/l1/d008,2		; [hit x2]
; . bp 1/l2/d010		; [hit]
; . bp 1/l1/d018,2		; [hit x2]
; . bp rom/ff58			; [hit x2]
; . bp 0/bf00			; [hit]
; . bp 1/bf01			; [hit]
; . bp 0/478			; [hit]
; . bp 0/2000			; [hit]
; . bp 1/479			; [hit]
; . bp 1/2001			; [hit]
;
; Test: (CPU r/w memory)
; NB. test0-testD all use the following BPs: (see the specific test for the BP hit pattern)
; . bpm l1/d000
; . bpm 0/l1/d001
; . bpm 1/l2/d002
; . bpm rom/d003
; . bpmw l1/d004
; . bpmw 0/l1/d005
; . bpmw 1/l2/d006
; . bpmw rom/d007
; . bpmw 0/l1/d008,2
; . bpmw 1/l2/d00a,3
; . bpmr l1/d00d
; . bpmr 0/l1/d00f,2
; . bpmr 1/l2/d011,3
; . bpmr rom/d015
;
; *** RamWorks tests ***
; TODO
;
;
; *** Saturn tests ***
; TODO
;

zpTmp = $fd

!zone code

entrypoint
	lda		$fc
	sta		saveFC
	lda		$fd
	sta		saveFD
	lda		$fe
	sta		saveFE
	lda		$ff
	sta		saveFF

;
; *** DMA tests ***
;

	;
	; Reads from block #1, when LC is write-enabled
	;

	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	
	lda		#2
	sta		zpTmp

rd_next_lc
	lda		#<mem_blk_r_data
	sta		$fe
	lda		#>mem_blk_r_data
	sta		$ff

loop1	ldy		#0
		lda		($fe),y
		sta		param_mem_block_l
		iny
		lda		($fe),y
		sta		param_mem_block_h
		jsr 	ENTRYPOINT_SMARTPORT
!zone data
mli0_0	!byte	CMD_READ
mli0_1	!byte	<param	; param_l
mli0_2	!byte	>param	; param_h
!zone code
		bcc		+
		jmp error_read
+

		lda		$fe
		clc
		adc		#SIZE_MEMBLK_DATA
		sta		$fe
		bcc		+
			inc		$ff
+

		ldy		#0
		lda		($fe),y
		iny
		ora		($fe),y
		bne		loop1

	bit		$c08f
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1

	dec		zpTmp
	bne		rd_next_lc

	;
	; Writes to block #1, when LC is write-enabled
	;

	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2

	lda		#2
	sta		zpTmp

wr_next_lc
	lda		#<mem_blk_w_data
	sta		$fe
	lda		#>mem_blk_w_data
	sta		$ff

loop2	ldy		#0
		lda		($fe),y
		sta		param_mem_block_l
		iny
		lda		($fe),y
		sta		param_mem_block_h
		jsr 	ENTRYPOINT_SMARTPORT
!zone data
mli1_0	!byte	CMD_WRITE
mli1_1	!byte	<param	; param_l
mli1_2	!byte	>param	; param_h
!zone code
		bcc		+
		jmp error_write
+

		lda		$fe
		clc
		adc		#SIZE_MEMBLK_DATA
		sta		$fe
		bcc		+
			inc		$ff
+

		ldy		#0
		lda		($fe),y
		iny
		ora		($fe),y
		bne		loop2

	bit		$c08f
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1

	dec		zpTmp
	bne		wr_next_lc

;
; *** CPU tests for 'bp' ***
;

CPUTests

	;
	; 'bp' tests in main/aux LC using ALTZP & LC soft-switches
	;

	lda 	#$60		; RTS

	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d000

	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d007
	sta		$d008
	sta		$d009
	sta		$d00a
	sta		ROMRTS		; main/lc

	sta		SW_ALTZPON	; ENA: ALTZP & LC

	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d010

	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d017
	sta		$d018
	sta		$d019
	sta		$d01a
	sta		ROMRTS		; aux/lc

	sta		SW_ALTZPOFF	; DIS: ALTZP & LC

	;

	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	jsr		$d000		; [hit]

	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	jsr		$d007		; no BP hit
	jsr		$d008		; [hit]
	jsr		$d009		; [hit]
	jsr		$d00a		; no BP hit
	jsr		ROMRTS		; no BP hit

	sta		SW_ALTZPON	; ENA: ALTZP & LC

	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	jsr		$d010		; [hit]

	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	jsr		$d017		; no BP hit
	jsr		$d018		; [hit]
	jsr		$d019		; [hit]
	jsr		$d01a		; no BP hit
	jsr		ROMRTS		; no BP hit

	sta		SW_ALTZPOFF	; DIS: ALTZP & LC

	bit		$c081		; Read ROM; write RAM; use $D000 bank 2 (RESET default)
	jsr		ROMRTS		; [hit]

	bit		$c082		; Read ROM; protected RAM
	jsr		ROMRTS		; [hit]

	;
	; 'bp' tests in main/aux $200-$BFFF using RAMRD/RAMWRT soft-switches
	;

	sta		SW_80STOREOFF

	lda 	#$60		; RTS
	ldx		#$00		; BRK

	sta		$478		; RTS, BRK
	stx		$479
	sta		$2000		; RTS, BRK
	stx		$2001
	sta		$bf00		; RTS, BRK
	stx		$bf01
	sta		SW_RAMWRTON		; Write enable aux memory from $0200-$BFFF
	stx		$478		; BRK, RTS
	sta		$479
	stx		$2000		; BRK, RTS
	sta		$2001
	stx		$bf00		; BRK, RTS
	sta		$bf01
	sta		SW_RAMWRTOFF	; Write enable main memory from $0200-$BFFF

	; Duplicate CPU test code to same location in aux mem
	lda		#<CPUTests
	sta		$3c			; src start
	sta		$42			; dst start
	lda		#>CPUTests
	sta		$3d			; src start
	sta		$43			; dst start
	lda		#<CPUTests_end
	sta		$3e
	lda		#>CPUTests_end
	sta		$3f
	sec					; C=1: main->aux
	jsr		AUXMOVE

	; Test RAMRD
	jsr		$bf00		; [hit]
	sta		SW_RAMRDON		; Read enable aux memory from $0200-$BFFF
	; Now running from aux (but stack in main mem)
	jsr		$bf01		; [hit]
	sta		SW_RAMRDOFF		; Read enable main memory from $0200-$BFFF
	; Now running from main

	;
	; 'bp' tests in main/aux TEXT/HIRES PAGE1 using 80STORE/PAGE2 soft-switches
	;

	; Test 80STORE/PAGE2
	sta		SW_80STOREON
	bit		SW_PAGE2OFF
	bit		SW_HIRESOFF
	jsr		$478		; [hit]
	jsr		$2000		; [hit]
	bit		SW_PAGE2ON
	jsr		$479		; [hit]
	bit		SW_HIRESON
	jsr		$2001		; [hit]
	bit		SW_PAGE2OFF
	bit		SW_HIRESOFF
	sta		SW_80STOREOFF

CPUTests_end
	nop

;
; *** CPU tests for 'bpm' ***
;

test0
	; bpm l1/d000
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d000		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d000		; [hit]
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d000		; [hit]
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	sta		$d000		; [hit] - because "bpm" is r/w ("l1" => RAM, whether protected or not) - use "bpmw" instead if you want to ignore this [*1]
	bit		$c08a		; Read ROM; protected RAM, bank 1
	sta		$d000		; no BP hit

test1
	; bpm 0/l1/d001
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d001		; no BP hit
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d001		; [hit]
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d001		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	sta		$d001		; [hit] (see [*1] above)
	bit		$c08a		; Read ROM; protected RAM, bank 1
	sta		$d001		; no BP hit

test2
	; bpm 1/l2/d002
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d002		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	sta		$d002		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d002		; [hit]
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	sta		$d002		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	sta		$d002		; no BP hit

test3
	; bpm rom/d003
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d003		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	sta		$d002		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d003		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	sta		$d003		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	sta		$d003		; [hit]

	; bpmw tests:

test4
	; bpmw l1/d004
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d004		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d004		; [hit]
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d004		; [hit]
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	sta		$d004		; no BP hit
	bit		$c08a		; Read ROM; protected RAM, bank 1
	sta		$d004		; no BP hit

test5
	; bpmw 0/l1/d005
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d005		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d005		; [hit]
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d005		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	sta		$d005		; no BP hit
	bit		$c08a		; Read ROM; protected RAM, bank 1
	sta		$d005		; no BP hit

test6
	; bpmw 1/l2/d006
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d006		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	sta		$d006		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d006		; [hit]
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	sta		$d006		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	sta		$d006		; no BP hit

test7
	; bpmw rom/d007
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d007		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	sta		$d007		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d007		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	sta		$d007		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	sta		$d007		; [hit]

test8
	; bpmw 0/l1/d008,2
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d008		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d007		; no BP hit
	sta		$d008		; [hit]
	sta		$d009		; [hit]
	sta		$d00a		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d008		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	sta		$d008		; no BP hit
	bit		$c08a		; Read ROM; protected RAM, bank 1
	sta		$d008		; no BP hit

test9
	; bpmw 1/l2/d00a,3
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d00a		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	sta		$d00a		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d009		; no BP hit
	sta		$d00a		; [hit]
	sta		$d00b		; [hit]
	sta		$d00c		; [hit]
	sta		$d00d		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	sta		$d00a		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	sta		$d00a		; no BP hit

	; bpmr tests:

testA
	; bpmr l1/d00d
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	bit		$d00d		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	bit		$d00d		; [hit]
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	bit		$d00d		; [hit]
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	bit		$d00d		; [hit]
	bit		$c08a		; Read ROM; protected RAM, bank 1
	bit		$d00d		; no BP hit

testB
	; bpmr 0/l1/d00f,2
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	bit		$d00f		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	bit		$d00e		; no BP hit
	bit		$d00f		; [hit]
	bit		$d010		; [hit]
	bit		$d011		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	bit		$d00f		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	bit		$d00f		; [hit]
	bit		$c08a		; Read ROM; protected RAM, bank 1
	bit		$d00f		; no BP hit

testC
	; bpmr 1/l2/d011,3
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	bit		$d011		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	bit		$d011		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	bit		$d00f		; no BP hit
	bit		$d011		; [hit]
	bit		$d012		; [hit]
	bit		$d013		; [hit]
	bit		$d014		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	bit		$d011		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	bit		$d011		; no BP hit

testD
	; bpmr rom/d015
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	bit		$d015		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	bit		$d015		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	bit		$d015		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	bit		$d015		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	bit		$d015		; [hit]

	;

success
	lda		#<msg0
	ldx		#>msg0
	jsr		print
	jmp		done

error_read
	lda		#<msg1
	ldx		#>msg1
	jsr		print
	jmp		done

error_write
	lda		#<msg2
	ldx		#>msg2
	jsr		print
	jmp		done

	;

done
	lda		saveFC
	sta		$fc
	lda		saveFD
	sta		$fd
	lda		saveFE
	sta		$fe
	lda		saveFF
	sta		$ff

	rts

;--------------------------------------

; Pre: X:A = msg
print
	bit		$c081
	bit		$c081		; Read ROM; write RAM; use $D000 bank 2 (RESET default)

	sta		$fe
	stx		$ff

	ldy		#0
.loop	lda		($fe),y
		beq		.pdone
		ora		#$80	; set high bit
		tax
		tya
		pha
		txa
		jsr		COUT
		pla
		tay
		iny
		bne 	.loop
.pdone
	rts

;------------------------------------------------------------------------------

!zone data

saveFC			!byte 0
saveFD			!byte 0
saveFE			!byte 0
saveFF			!byte 0

param
	!byte	3	; param length
	!byte	1	; unit
param_mem_block_l
	!byte	0	; mem_block_l
param_mem_block_h
	!byte	0	; mem_block_h
	!byte	1	; disk_block_l
	!byte	0	; disk_block_h

SIZE_MEMBLK_DATA = 3

!macro MEMBLK addr,carry {
	!word	addr
	!byte	carry
}

mem_blk_r_data
	+MEMBLK	$be00,0	; save block 1 (expect C=0)
	+MEMBLK	$d000,0	; (expect C=0)
	+MEMBLK	$d200,0	; (expect C=0)
	+MEMBLK	$d400,0	; (expect C=0)
	+MEMBLK	$d600,0	; (expect C=0)
	+MEMBLK	$d700,0	; (expect C=0)
	+MEMBLK	$d700,0	; (expect C=0)
	+MEMBLK $0000,0	;(end)

mem_blk_w_data
	+MEMBLK	$d800,0	; (expect C=0)
	+MEMBLK	$da00,0	; (expect C=0)
	+MEMBLK	$dc00,0	; (expect C=0)
	+MEMBLK	$de00,0	; (expect C=0)
	+MEMBLK	$df00,0	; (expect C=0)
	+MEMBLK	$df00,0	; (expect C=0)
	+MEMBLK	$be00,0	; restore block 1 (expect C=0)
	+MEMBLK $0000,0	;(end)

msg0 !text "All tests OK - for HDD r/w & CPU r/w",0xd
msg0End !text 0

msg1 !text "Read error for block 1!",0xd
msg1End !text 0

msg2 !text "Write error for block 1!",0xd
msg2End !text 0
