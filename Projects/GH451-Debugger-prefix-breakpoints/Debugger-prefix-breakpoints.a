;ACME 0.96.4

!cpu 6502	; Compatible with all Apple2's
!to "Debugger-prefix-breakpoints", plain
!sl "Debugger-prefix-breakpoints.labels"
*=$6000

;------------------------------------------------------------------------------

!source "AppleDefs.a"
!source "BreakpointCard.a"
!source "HardDiskDefs.a"

;------------------------------------------------------------------------------

; Debugger breakpoint tests to check the address prefixes
;
; Enhanced //e, -aux rw3 (1MiB = 16x 64KiB), -s3 saturn (128KiB = 8x 16KiB)
;
; *** DMA tests ***
;
; Tests: (DMA write / HDD read), LC is r/w & 4K-bank 2
; NB. leave $d000-d1ff without a watchpoint so that CPU tests can use this range
; . bpmw da00			: read block #1 to da00-dbff [hit]
; . bpmw 0/d200			: read block #1 to d200-d3ff [hit]
; . bpmw 0/l1/d400		: read block #1 to d400-d5ff
; . bpmw 0/l2/d600		: read block #1 to d600-d7ff [hit]
; . bpmw 0/l1/d680,100	: read block #1 to d700-d900, BP range overlapping before d700, hit at d700
; . bpmw 0/l1/d880,100	: read block #1 to d700-d900, BP range overlapping after  d700, hit at d880
;
; Tests: (DMA write / HDD read), LC is r/w & 4K-bank*1*
; NB. same BPs as 4K-bank 2 above
; . bpmw da00			: read block #1 to da00-dbff [hit]
; . bpmw 0/d200			: read block #1 to d200-d3ff [hit]
; . bpmw 0/l1/d400		: read block #1 to d400-d5ff [hit]
; . bpmw 0/l2/d600		: read block #1 to d600-d7ff
; . bpmw 0/l1/d680,100	: read block #1 to d700-d900, BP range overlapping before d700, hit at d700 [hit]
; . bpmw 0/l1/d880,100	: read block #1 to d700-d900, BP range overlapping after  d700, hit at d880 [hit]
;
; Tests: (DMA read  / HDD write), LC is r/w & 4K-bank 2
; . bpmr d800			: write block #1 to d800-d9ff [hit]
; . bpmr 0/da00			: write block #1 to da00-dbff [hit]
; . bpmr 0/l1/dc00		: write block #1 to dc00-ddff
; . bpmr 0/l2/de00		: write block #1 to de00-dfff [hit]
; . bpmr 0/l1/de80,100	: write block #1 to df00-e100, BP range overlapping before df00, hit at df00
; . bpmr 0/l1/e080,100	: write block #1 to df00-e100, BP range overlapping after  df00, hit at e080 [hit]
;
; Tests: (DMA read  / HDD write), LC is r/w & 4K-bank*1*
; NB. same BPs as 4K-bank 2 above
; . bpmr d800			: write block #1 to d800-d9ff [hit]
; . bpmr 0/da00			: write block #1 to da00-dbff [hit]
; . bpmr 0/l1/dc00		: write block #1 to dc00-ddff [hit]
; . bpmr 0/l2/de00		: write block #1 to de00-dfff
; . bpmr 0/l1/de80,100	: write block #1 to df00-e100, BP range overlapping before df00, hit at df00 [hit]
; . bpmr 0/l1/e080,100	: write block #1 to df00-e100, BP range overlapping after  df00, hit at e080 [hit]
;
; *** CPU tests ***
;
; Test: (CPU PC): using ALTZP, RAMRD & 80STORE/PAGE2 soft-switches
; . bp 0/l2/d000		; [hit]
; . bp 0/l1/d008,2		; [hit x2]
; . bp 1/l2/d010		; [hit]
; . bp 1/l1/d018,2		; [hit x2]
; . bp rom/ff58			; [hit x2]
; . bp 0/bf00			; [hit]
; . bp 1/bf01			; [hit]
; . bp 0/478			; [hit]
; . bp 0/2000			; [hit]
; . bp 1/479			; [hit]
; . bp 1/2001			; [hit]
;
; Test: (CPU r/w memory)
; NB. test0-testD all use the following BPs: (see the specific test for the BP hit pattern)
; . bpm l1/d100
; . bpm 0/l1/d101
; . bpm 1/l2/d102
; . bpm rom/d103
; . bpmw l1/d104
; . bpmw 0/l1/d105
; . bpmw 1/l2/d106
; . bpmw rom/d107
; . bpmw 0/l1/d108,2
; . bpmw 1/l2/d10a,3
; . bpmr l1/d10d
; . bpmr 0/l1/d10f,2
; . bpmr 1/l2/d111,3
; . bpmr rom/d115
;
; *** RamWorks tests ***
; TODO
;
;
; *** Saturn tests ***
; TODO
;

zpStr = $fa
zpStrH = $fb
zpCount = $fc
zpTmp = $fd
zpPtr = $fe
zpPtrH = $ff

!zone code

entrypoint
	lda		#1
	sta		cardDetected

	lda		$fa
	sta		saveFA
	lda		$fb
	sta		saveFB
	lda		$fc
	sta		saveFC
	lda		$fd
	sta		saveFD
	lda		$fe
	sta		saveFE
	lda		$ff
	sta		saveFF

	sei

	lda		#<MyISR
	sta		IRQL
	lda		#>MyISR
	sta		IRQH

	lda		cardDetected	; User can manually disable use of card with: "6001:0"
	beq		+
		ldy		#BPCARD_REG_ID4
-			tya
			cmp		BPCARD_IO_BASE,y
			bne		++
			iny
			cpy		#BPCARD_REG_ID15+1
			bne		-
			beq		+
++		lda		#0
		sta		cardDetected
+	lda		cardDetected
	bne		+
		lda		#<msg_noCard
		ldx		#>msg_noCard
		jsr		print
		; Wait for keypress...
-			lda		KBD
			bpl		-
		lda		KBDSTRB
+

	bit		BPCARD_CMD_RESET
;	bit		BPCARD_CMD_INTERCEPT_BY_CARD	; Not yet - otherwise can't single-step

	cli

;
; *** DMA tests ***
;

	;
	; Reads from block #1, when LC is write-enabled
	;

	lda		#0
	sta		testNum
	lda		#0
	sta		subTestNum

	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2

	lda		#<PreISR
	sta		_6502_INTERRUPT_VECTOR_L
	lda		#>PreISR
	sta		_6502_INTERRUPT_VECTOR_H

	lda		#2
	sta		zpTmp

	lda		#<mem_blk_r_data
	sta		zpPtr
	lda		#>mem_blk_r_data
	sta		zpPtrH

rd_next_lc
loop1	ldy		#0
		lda		(zpPtr),y		; # BPs
		beq		+
		sta		zpCount
-			lda		#BPTYPE_DMA
			sta		BPCARD_FIFO
			ldx		#BP_DMA_PARAM_SIZE
--				iny
				lda		(zpPtr),y
				sta		BPCARD_FIFO
				dex
				bne		--

			dec		zpCount
			bne		-
		;
+		iny
		lda		(zpPtr),y
		sta		param_mem_block_l
		iny
		lda		(zpPtr),y
		sta		param_mem_block_h
		;
		iny
		sty		zpCount
		lda		zpPtr
		clc
		adc		zpCount
		sta		zpPtr
		bcc		+
			inc		zpPtrH
+		;
		lda		cardDetected
		beq		+
			bit		BPCARD_CMD_INTERCEPT_BY_CARD
+		jsr 	ENTRYPOINT_SMARTPORT
!zone data
mli0_0	!byte	CMD_READ
mli0_1	!byte	<param	; param_l
mli0_2	!byte	>param	; param_h
!zone code
		bit		BPCARD_CMD_INTERCEPT_BY_DEBUGGER
		bcc		+
		jmp error_read
+

		ldy		#0
		lda		(zpPtr),y
		iny
		ora		(zpPtr),y
		iny
		ora		(zpPtr),y
		bne		loop1

	bit		$c08f
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1

	lda		#<mem_blk_r_data2
	sta		zpPtr
	lda		#>mem_blk_r_data2
	sta		zpPtrH

	dec		zpTmp
	bne		rd_next_lc

	;
	; Writes to block #1, when LC is write-enabled
	;

	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2

	lda		#2
	sta		zpTmp

	lda		#<mem_blk_w_data
	sta		zpPtr
	lda		#>mem_blk_w_data
	sta		zpPtrH

wr_next_lc
loop2	ldy		#0
		lda		(zpPtr),y		; # BPs
		beq		+
		sta		zpCount
-			lda		#BPTYPE_DMA
			sta		BPCARD_FIFO
			ldx		#BP_DMA_PARAM_SIZE
--				iny
				lda		(zpPtr),y
				sta		BPCARD_FIFO
				dex
				bne		--

			dec		zpCount
			bne		-
		;
+		iny
		lda		(zpPtr),y
		sta		param_mem_block_l
		iny
		lda		(zpPtr),y
		sta		param_mem_block_h
		;
		iny
		sty		zpCount
		lda		zpPtr
		clc
		adc		zpCount
		sta		zpPtr
		bcc		+
			inc		zpPtrH
+		;
		lda		cardDetected
		beq		+
			bit		BPCARD_CMD_INTERCEPT_BY_CARD
+		jsr 	ENTRYPOINT_SMARTPORT
!zone data
mli1_0	!byte	CMD_WRITE
mli1_1	!byte	<param	; param_l
mli1_2	!byte	>param	; param_h
!zone code
		bit		BPCARD_CMD_INTERCEPT_BY_DEBUGGER
		bcc		+
		jmp error_write
+

		ldy		#0
		lda		(zpPtr),y
		iny
		ora		(zpPtr),y
		iny
		ora		(zpPtr),y
		bne		loop2

	bit		$c08f
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1

	lda		#<mem_blk_w_data2
	sta		zpPtr
	lda		#>mem_blk_w_data2
	sta		zpPtrH

	dec		zpTmp
	bne		wr_next_lc

;
; *** CPU tests for 'bp' ***
;

CPUTests

	;
	; 'bp' tests in main/aux LC using ALTZP & LC soft-switches
	;

	inc		testNum
	lda		#0
	sta		subTestNum

	lda		#<cpu_pc_breakpoints
	sta		zpPtr
	lda		#>cpu_pc_breakpoints
	sta		zpPtrH

	bit		BPCARD_CMD_RESET	; flush FIFO from previous tests

@next_bp
		ldy		#0
		lda		#BPTYPE_PC
		sta		BPCARD_FIFO
		ldx		#BP_CPU_PARAM_SIZE
--			lda		(zpPtr),y
			sta		BPCARD_FIFO
			iny
			dex
			bne		--

		lda		zpPtr
		clc
		adc		#BP_CPU_PARAM_SIZE
		sta		zpPtr
		bcc		+
			inc		zpPtrH
+
		ldy		#0
		lda		(zpPtr),y
		iny
		ora		(zpPtr),y
		iny
		ora		(zpPtr),y
		bne		@next_bp

	;

	lda 	#$60		; RTS

	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d000

	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d007
	sta		$d008
	sta		$d009
	sta		$d00a
	sta		ROMRTS		; main/lc

	sta		SW_ALTZPON	; ENA: ALTZP & LC

	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d010

	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d017
	sta		$d018
	sta		$d019
	sta		$d01a
	sta		ROMRTS		; aux/lc

	lda		#<PreISR
	sta		_6502_INTERRUPT_VECTOR_L
	lda		#>PreISR
	sta		_6502_INTERRUPT_VECTOR_H

	sta		SW_ALTZPOFF	; DIS: ALTZP & LC

	;

	lda		cardDetected
	beq		+
		bit		BPCARD_CMD_INTERCEPT_BY_CARD
+

	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	jsr		$d000		; [hit]

	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	jsr		$d007		; no BP hit
	jsr		$d008		; [hit]
	jsr		$d009		; [hit]
	jsr		$d00a		; no BP hit
	jsr		ROMRTS		; no BP hit

	sta		SW_ALTZPON	; ENA: ALTZP & LC

	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	jsr		$d010		; [hit]

	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	jsr		$d017		; no BP hit
	jsr		$d018		; [hit]
	jsr		$d019		; [hit]
	jsr		$d01a		; no BP hit
	jsr		ROMRTS		; no BP hit

	sta		SW_ALTZPOFF	; DIS: ALTZP & LC

	bit		$c081		; Read ROM; write RAM; use $D000 bank 2 (RESET default)
	jsr		ROMRTS		; [hit]

	bit		$c082		; Read ROM; protected RAM
	jsr		ROMRTS		; [hit]

	;
	; 'bp' tests in main/aux $200-$BFFF using RAMRD/RAMWRT soft-switches
	;

	sta		SW_80STOREOFF

	lda 	#$60		; RTS
	ldx		#$00		; BRK

	sta		$478		; RTS, BRK
	stx		$479
	sta		$2000		; RTS, BRK
	stx		$2001
	sta		$bf00		; RTS, BRK
	stx		$bf01
	sta		SW_RAMWRTON		; Write enable aux memory from $0200-$BFFF
	stx		$478		; BRK, RTS
	sta		$479
	stx		$2000		; BRK, RTS
	sta		$2001
	stx		$bf00		; BRK, RTS
	sta		$bf01
	sta		SW_RAMWRTOFF	; Write enable main memory from $0200-$BFFF

	; Duplicate CPU test code to same location in aux mem
	lda		#<CPUTests
	sta		$3c			; src start
	sta		$42			; dst start
	lda		#>CPUTests
	sta		$3d			; src start
	sta		$43			; dst start
	lda		#<CPUTests_end
	sta		$3e
	lda		#>CPUTests_end
	sta		$3f
	sec					; C=1: main->aux
	jsr		AUXMOVE

	; Test RAMRD
	jsr		$bf00		; [hit]
	sta		SW_RAMRDON		; Read enable aux memory from $0200-$BFFF
	; Now running from aux (but stack in main mem)
	jsr		$bf01		; [hit]
	sta		SW_RAMRDOFF		; Read enable main memory from $0200-$BFFF
	; Now running from main

	;
	; 'bp' tests in main/aux TEXT/HIRES PAGE1 using 80STORE/PAGE2 soft-switches
	;

	; Test 80STORE/PAGE2
	sta		SW_80STOREON
	bit		SW_PAGE2OFF
	bit		SW_HIRESOFF
	jsr		$478		; [hit]
	jsr		$2000		; [hit]
	bit		SW_PAGE2ON
	jsr		$479		; [hit]
	bit		SW_HIRESON
	jsr		$2001		; [hit]
	bit		SW_PAGE2OFF
	bit		SW_HIRESOFF
	sta		SW_80STOREOFF

	bit		BPCARD_CMD_INTERCEPT_BY_DEBUGGER

CPUTests_end
	nop

MEMTests

;
; *** CPU tests for 'bpm' ***
;

	inc		testNum
	lda		#0
	sta		subTestNum

	lda		#<cpu_mem_breakpoints
	sta		zpPtr
	lda		#>cpu_mem_breakpoints
	sta		zpPtrH

	bit		BPCARD_CMD_RESET	; flush FIFO from previous tests

@next_bp
		ldy		#0
		lda		#BPTYPE_MEM
		sta		BPCARD_FIFO
		ldx		#BP_MEM_PARAM_SIZE
--			lda		(zpPtr),y
			sta		BPCARD_FIFO
			iny
			dex
			bne		--

		lda		zpPtr
		clc
		adc		#BP_MEM_PARAM_SIZE
		sta		zpPtr
		bcc		+
			inc		zpPtrH
+
		ldy		#0
		lda		(zpPtr),y
		iny
		ora		(zpPtr),y
		iny
		ora		(zpPtr),y
		bne		@next_bp

	;

	lda		cardDetected
	beq		+
		bit		BPCARD_CMD_INTERCEPT_BY_CARD
+
	;

test0
	; bpm l1/d100
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d100		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d100		; [hit]
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d100		; [hit]
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	sta		$d100		; [hit] - because "bpm" is r/w ("l1" => RAM, whether protected or not) - use "bpmw" instead if you want to ignore this [*1]
	bit		$c08a		; Read ROM; protected RAM, bank 1
	sta		$d100		; no BP hit

test1
	; bpm 0/l1/d101
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d101		; no BP hit
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d101		; [hit]
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d101		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	sta		$d101		; [hit] (see [*1] above)
	bit		$c08a		; Read ROM; protected RAM, bank 1
	sta		$d101		; no BP hit

test2
	; bpm 1/l2/d102
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d102		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	sta		$d102		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d102		; [hit]
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	sta		$d102		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	sta		$d102		; no BP hit

test3
	; bpm rom/d103
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d103		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	sta		$d102		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d103		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	sta		$d103		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	sta		$d103		; [hit]

	; bpmw tests:

test4
	; bpmw l1/d104
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d104		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d104		; [hit]
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d104		; [hit]
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	sta		$d104		; no BP hit
	bit		$c08a		; Read ROM; protected RAM, bank 1
	sta		$d104		; no BP hit

test5
	; bpmw 0/l1/d105
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d105		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d105		; [hit]
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d105		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	sta		$d105		; no BP hit
	bit		$c08a		; Read ROM; protected RAM, bank 1
	sta		$d105		; no BP hit

test6
	; bpmw 1/l2/d106
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d106		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	sta		$d106		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d106		; [hit]
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	sta		$d106		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	sta		$d106		; no BP hit

test7
	; bpmw rom/d107
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d107		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	sta		$d107		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d107		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	sta		$d107		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	sta		$d107		; [hit]

test8
	; bpmw 0/l1/d108,2
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	sta		$d108		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	sta		$d107		; no BP hit
	sta		$d108		; [hit]
	nop					; (Breakpoint card: need an opcode gap between BP hits)
	sta		$d109		; [hit]
	sta		$d10a		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d108		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	sta		$d108		; no BP hit
	bit		$c08a		; Read ROM; protected RAM, bank 1
	sta		$d108		; no BP hit

test9
	; bpmw 1/l2/d10a,3
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	sta		$d10a		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	sta		$d10a		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	sta		$d109		; no BP hit
	sta		$d10a		; [hit]
	nop					; (Breakpoint card: need an opcode gap between BP hits)
	sta		$d10b		; [hit]
	nop					; (Breakpoint card: need an opcode gap between BP hits)
	sta		$d10c		; [hit]
	sta		$d10d		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	sta		$d10a		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	sta		$d10a		; no BP hit

	; bpmr tests:

testA
	; bpmr l1/d10d
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	bit		$d10d		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	bit		$d10d		; [hit]
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	bit		$d10d		; [hit]
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	bit		$d10d		; [hit]
	bit		$c08a		; Read ROM; protected RAM, bank 1
	bit		$d10d		; no BP hit

testB
	; bpmr 0/l1/d10f,2
	bit		$c083
	bit		$c083		; Read RAM, write RAM, use $D000 bank 2
	bit		$d10f		; no BP hit
	bit		$c08f		; Read RAM, write RAM, use $D000 bank 1
	bit		$d10e		; no BP hit
	bit		$d10f		; [hit]
	nop					; (Breakpoint card: need an opcode gap between BP hits)
	bit		$d110		; [hit]
	bit		$d111		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	bit		$d10f		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c088		; Read RAM; protected RAM, bank 1
	bit		$d10f		; [hit]
	bit		$c08a		; Read ROM; protected RAM, bank 1
	bit		$d10f		; no BP hit

testC
	; bpmr 1/l2/d111,3
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	bit		$d111		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	bit		$d111		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	bit		$d10f		; no BP hit
	bit		$d111		; [hit]
	nop					; (Breakpoint card: need an opcode gap between BP hits)
	bit		$d112		; [hit]
	nop					; (Breakpoint card: need an opcode gap between BP hits)
	bit		$d113		; [hit]
	bit		$d114		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	bit		$d111		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	bit		$d111		; no BP hit

testD
	; bpmr rom/d115
	bit		$c08b
	bit		$c08b		; Read RAM, write RAM, use $D000 bank 1
	bit		$d115		; no BP hit
	bit		$c087		; Read RAM, write RAM, use $D000 bank 2
	bit		$d115		; no BP hit
	sta		SW_ALTZPON	; ENA: ALTZP & LC
	bit		$d115		; no BP hit
	sta		SW_ALTZPOFF	; DIS: ALTZP & LC
	bit		$c080		; Read RAM; protected RAM, bank 2
	bit		$d115		; no BP hit
	bit		$c082		; Read ROM; protected RAM, bank 2
	bit		$d115		; [hit]

	;

	bit		BPCARD_CMD_INTERCEPT_BY_DEBUGGER

	;

success
	lda		#<msg0
	ldx		#>msg0
	jsr		print
	jmp		done

error_read
	lda		#<msg1
	ldx		#>msg1
	jsr		print
	jmp		done

error_write
	lda		#<msg2
	ldx		#>msg2
	jsr		print
	jmp		done

	;

done
	bit		BPCARD_CMD_INTERCEPT_BY_DEBUGGER

	lda		saveFA
	sta		$fa
	lda		saveFB
	sta		$fb
	lda		saveFC
	sta		$fc
	lda		saveFD
	sta		$fd
	lda		saveFE
	sta		$fe
	lda		saveFF
	sta		$ff

	rts

;--------------------------------------

; Pre: X:A = msg
; . ALTZPOFF (for main ZP)
print
	bit		$c081
	bit		$c081		; Read ROM; write RAM; use $D000 bank 2 (RESET default)

	sta		zpStr
	stx		zpStrH

	ldy		#0
@loop	lda		(zpStr),y
		beq		@done
		ora		#$80	; set high bit
		tax
		tya
		pha
		txa
		jsr		COUT
		pla
		tay
		iny
		bne 	@loop
@done
	rts

;------------------------------------------------------------------------------

!macro ISR_ENTRY {
	txa
	pha
	tya
	pha
}

!macro ISR_EXIT {
	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti
}

;------------------------------------------------------------------------------

; When LC is switched in, then need to preserve A-reg:
PreISR
	sta		$45
	; drop into ISR...

MyISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	+ISR_ENTRY

!if 0 {
	; NB. Only helps for DMA tests, as they do one BP at a time
;	lda		subTestNum
;	cmp		#1
;	bne		@skip
		bit		BPCARD_CMD_INTERCEPT_BY_DEBUGGER	; clear IRQ
		nop
;@skip
}

	lda		BPCARD_STATUS	; clear IRQ
	bmi		@ok

	sta		SW_ALTZPOFF

	lda		#<msg3
	ldx		#>msg3
	jsr		print			; post: ROM enabled (LC RAM disabled)
	ldx		testNum
	jsr		PRNTX
	lda		#$80+':'
	jsr		COUT
	ldx		subTestNum
	jsr		PRNTX

	lda		#<msg4
	ldx		#>msg4
	jsr		print
	ldx		BPCARD_STATUS
	jsr		PRNTX

	jsr		CROUT

-	jmp		-	; hang!

	;

@ok
	; Save ZP & LC state
	lda		_6502_INTERRUPT_VECTOR_H
	pha
	eor		#$ff
	sta		_6502_INTERRUPT_VECTOR_H

	bit		RDLCRAM			; b7: LC 1=RAM, 0=ROM
	php
	bit		RDLCBNK2		; b7: LC 1=bank2, 0=bank1
	php
	lda		RDALTZP			; b7: 1=ALTZPON, 0=ALTZPOFF
	sta		saveAltZP

	;

	sta		SW_ALTZPOFF

	lda		#<msg3
	ldx		#>msg3
	jsr		print			; post: ROM enabled (LC RAM disabled)
	ldx		testNum
	jsr		PRNTX
	lda		#$80+':'
	jsr		COUT
	ldx		subTestNum
	jsr		PRNTX

	jsr		CROUT

	;

@done
	; Restore ZP & LC state
	ldy		#0
	bit		saveAltZP
	bpl		+
	iny
+	sta		SW_ALTZPOFF,y

	ldy		#0				; bank2
	plp						; RDLCBNK2
	bmi		+
	ldy		#8				; bank1

+	sta		$C080,y			; RAM read, write protect
	plp						; RDLCRAM
	bmi		+
	sta		$C082,y			; ROM read, write protect

+	pla
	cmp		_6502_INTERRUPT_VECTOR_H
	beq		+
	ldx		$C083,y			; (Must be CPU read)
	ldx		$C083,y			; RAM write enabled
	sta		_6502_INTERRUPT_VECTOR_H
+

	inc		subTestNum

	+ISR_EXIT

saveAltZP	!byte 0

;------------------------------------------------------------------------------

!zone data

saveFA		!byte 0
saveFB		!byte 0
saveFC		!byte 0
saveFD		!byte 0
saveFE		!byte 0
saveFF		!byte 0

testNum		!byte 0
subTestNum	!byte 0

cardDetected	!byte 0

;------------------------------------------------------------------------------

param
	!byte	3	; param length
	!byte	1	; unit
param_mem_block_l
	!byte	0	; mem_block_l
param_mem_block_h
	!byte	0	; mem_block_h
	!byte	1	; disk_block_l
	!byte	0	; disk_block_m
	!byte	0	; disk_block_h

	;

BP_DMA_PARAM_SIZE = 5

!macro NUM_BP num {
	!byte 	num
}

!macro BP_PARAMS_R bp_startAddr,bp_len {
	!word	bp_startAddr
	!word	bp_startAddr+bp_len-1
	!byte	BPACCESS_W	; Write to mem (by HDD read)
}

!macro BP_PARAMS_W bp_startAddr,bp_len {
	!word	bp_startAddr
	!word	bp_startAddr+bp_len-1
	!byte	BPACCESS_R	; Read from mem (by HDD write)
}

!macro HDD_ADDR_DST addr {	; for HDD read
	!word	addr
}

!macro HDD_ADDR_SRC addr {	; for HDD write
	!word	addr
}

	;

mem_blk_r_data				; test: 00:[00-05]
	+NUM_BP 0
		+HDD_ADDR_DST $be00			; save block 1
	+NUM_BP 1
		+BP_PARAMS_R $da00,1
		+HDD_ADDR_DST $da00
	+NUM_BP 1
		+BP_PARAMS_R $d200,1
		+HDD_ADDR_DST $d200
	+NUM_BP 0
		+HDD_ADDR_DST $d400
	+NUM_BP 1
		+BP_PARAMS_R $d600,1
		+HDD_ADDR_DST $d600
	+NUM_BP 0
		+HDD_ADDR_DST $d700
	!byte 0,0,0		;(end)

mem_blk_r_data2				; test: 00:[06-0A]
	+NUM_BP 1
		+BP_PARAMS_R $da00,1
		+HDD_ADDR_DST $da00
	+NUM_BP 1
		+BP_PARAMS_R $d200,1
		+HDD_ADDR_DST $d200
	+NUM_BP 1
		+BP_PARAMS_R $d400,1
		+HDD_ADDR_DST $d400
	+NUM_BP 2
		+BP_PARAMS_R $d680,$100		; [b#4] DMA to: 0/l1/d680-d6ff
		+BP_PARAMS_R $d680,$100		; [b#4] DMA to: 0/l1/d700-d77f
		+HDD_ADDR_DST $d600
	+NUM_BP 2
		+BP_PARAMS_R $d680,$100		; [b#4] DMA to: 0/l1/d700-d77f
		+BP_PARAMS_R $d880,$100		; [b#5] DMA to: 0/l1/d880-d8ff
		+HDD_ADDR_DST $d700
	!byte 0,0,0		;(end)

mem_blk_w_data				; test: 00:[0B-0F]
	+NUM_BP 1
		+BP_PARAMS_W $d800,1
		+HDD_ADDR_SRC $d800
	+NUM_BP 1
		+BP_PARAMS_W $da00,1
		+HDD_ADDR_SRC $da00
	+NUM_BP 0
		+HDD_ADDR_SRC $dc00
	+NUM_BP 1
		+BP_PARAMS_W $de00,1		; [b#9] DMA from: 0/l2/de00
		+HDD_ADDR_SRC $de00
	+NUM_BP 1
		+BP_PARAMS_W $e080,$100		; [b#B] DMA from: 0/e080-e0ff
		+HDD_ADDR_SRC $df00
	!byte 0,0,0		;(end)

mem_blk_w_data2				; test: 00:[10-14]
	+NUM_BP 1
		+BP_PARAMS_W $d800,1
		+HDD_ADDR_SRC $d800
	+NUM_BP 1
		+BP_PARAMS_W $da00,1
		+HDD_ADDR_SRC $da00
	+NUM_BP 1
		+BP_PARAMS_W $dc00,1
		+HDD_ADDR_SRC $dc00
	+NUM_BP 2
		+BP_PARAMS_W $de80,$100		; [b#A] DMA from: 0/l1/de80-deff
		+BP_PARAMS_W $de80,$100		; [b#A] DMA from: 0/l1/df00-df7f
		+HDD_ADDR_SRC $de00
	+NUM_BP 2
		+BP_PARAMS_W $de80,$100		; [b#A] DMA from: 0/l1/df00-df7f
		+BP_PARAMS_W $e080,$100		; [b#B] DMA from: 0/e000-e0ff
		+HDD_ADDR_SRC $df00
	+NUM_BP 0
		+HDD_ADDR_SRC $be00			; restore block 1
	!byte 0,0,0		;(end)

;------------------------------------------------------------------------------

BP_CPU_PARAM_SIZE = 5

!macro CPU_BP_PARAMS bp_startAddr {
	!word	bp_startAddr
	!word	bp_startAddr
	!byte	BPACCESS_R
}

cpu_pc_breakpoints			; test: 01:[00-0D]
	+CPU_BP_PARAMS $d000
	+CPU_BP_PARAMS $d008
	+CPU_BP_PARAMS $d009
	+CPU_BP_PARAMS $d010
	+CPU_BP_PARAMS $d018
	+CPU_BP_PARAMS $d019
	+CPU_BP_PARAMS $ff58
	+CPU_BP_PARAMS $ff58
	+CPU_BP_PARAMS $bf00
	+CPU_BP_PARAMS $bf01
	+CPU_BP_PARAMS $478
	+CPU_BP_PARAMS $2000
	+CPU_BP_PARAMS $479
	+CPU_BP_PARAMS $2001
	!byte 0,0,0

;------------------------------------------------------------------------------

BP_MEM_PARAM_SIZE = 5

!macro MEM_BP_PARAMS_R bp_startAddr {
	!word	bp_startAddr
	!word	bp_startAddr
	!byte	BPACCESS_R
}

!macro MEM_BP_PARAMS_W bp_startAddr {
	!word	bp_startAddr
	!word	bp_startAddr
	!byte	BPACCESS_W
}

!macro MEM_BP_PARAMS_RW bp_startAddr {
	!word	bp_startAddr
	!word	bp_startAddr
	!byte	BPACCESS_RW
}

cpu_mem_breakpoints			; test: 02:[00-1A]
	+MEM_BP_PARAMS_RW $d100
	+MEM_BP_PARAMS_RW $d100
	+MEM_BP_PARAMS_RW $d100
	+MEM_BP_PARAMS_RW $d101
	+MEM_BP_PARAMS_RW $d101
	+MEM_BP_PARAMS_RW $d102
	+MEM_BP_PARAMS_RW $d103
	+MEM_BP_PARAMS_W $d104
	+MEM_BP_PARAMS_W $d104
	+MEM_BP_PARAMS_W $d105
	+MEM_BP_PARAMS_W $d106
	+MEM_BP_PARAMS_W $d107
	+MEM_BP_PARAMS_W $d108
	+MEM_BP_PARAMS_W $d109
	+MEM_BP_PARAMS_W $d10a
	+MEM_BP_PARAMS_W $d10b
	+MEM_BP_PARAMS_W $d10c
	+MEM_BP_PARAMS_R $d10d
	+MEM_BP_PARAMS_R $d10d
	+MEM_BP_PARAMS_R $d10d
	+MEM_BP_PARAMS_R $d10f
	+MEM_BP_PARAMS_R $d110
	+MEM_BP_PARAMS_R $d10f
	+MEM_BP_PARAMS_R $d111
	+MEM_BP_PARAMS_R $d112
	+MEM_BP_PARAMS_R $d113
	+MEM_BP_PARAMS_R $d115
	!byte 0,0,0

;------------------------------------------------------------------------------

msg_noCard !text "No Breakpoint card detected. Continue?",0xd
msg_noCardEnd !text 0

msg0 !text "All tests OK - for HDD r/w & CPU r/w",0xd
msg0End !text 0

msg1 !text "Read error for block 1!",0xd
msg1End !text 0

msg2 !text "Write error for block 1!",0xd
msg2End !text 0

msg3 !text "Test #"
msg3End !text 0

msg4 !text " - BP mismatch. Status="
msg4End !text 0
